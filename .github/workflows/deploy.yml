name: Deploy Changed Stacks to Test Environment

on:
  pull_request:
    types: [opened, reopened, synchronize] # Trigger on new PRs, reopened PRs, or new commits to an open PR

env:
  AWS_REGION: us-east-1 # Set your default AWS region for the test environment
  TEST_ENVIRONMENT_NAME: test # The exact environment name your deploy.sh expects for 'test'

jobs:
  # Job 1: Identify all changed service directories that can be deployed
  identify-deployable-services:
    runs-on: ubuntu-latest
    outputs:
      # Output a JSON array of directories to deploy, for the matrix strategy
      stack_dirs: ${{ steps.get_changed_service_dirs.outputs.STACK_DIRS_TO_DEPLOY }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 
      
      - name: Get changed service directories with deploy.sh and .yaml
        id: get_changed_service_dirs
        run: |
          set -euxo pipefail # Keep this for detailed debugging output

          
          # Ensure full history is fetched for reliable diffing
          # This should be handled by `fetch-depth: 0` in actions/checkout, but is here as a safeguard.
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }} || true
          echo "Git fetch for base ref complete."

          # Get all changed files between the base branch and the PR head.
          # The '|| true' ensures the command itself doesn't fail the script if there's no diff,
          # or if the refs don't exist (though fetch-depth:0 should prevent the latter).
          # Redirect stderr to /dev/null to clean up error messages from git for non-existing refs.
          RAW_CHANGED_FILES=$(git diff --name-only ${{ github.base_ref }}...${{ github.sha }} 2>/dev/null || true)

          echo "--- Raw git diff output ---"
          echo "${RAW_CHANGED_FILES}"
          echo $(git diff --name-only HEAD^ HEAD)
          echo "--- End raw git diff output ---"

          # Check if there are any files reported by git diff
          if [ -z "$RAW_CHANGED_FILES" ]; then
            echo "No file changes detected by git diff between ${{ github.base_ref }} and ${{ github.sha }}."
            echo "STACK_DIRS_TO_DEPLOY=[]" >> $GITHUB_OUTPUT # Output empty array for matrix
            exit 0 # Exit successfully as there's nothing to deploy
          fi

          # Filter for .yaml files and get their unique parent directories
          # Use 'grep -E' for extended regex and '|| true' to prevent script failure if no .yaml files are matched.
          # Use 'while read' loop for robust line processing, especially with filenames containing spaces.
          CHANGED_YAML_DIRS=""
          while IFS= read -r line; do
            if [[ "$line" =~ \.yaml$ ]]; then
              CHANGED_YAML_DIRS+="$(dirname "$line")\n"
            fi
          done <<< "$RAW_CHANGED_FILES"
          
          # Remove duplicate directory names and remove trailing newline
          CHANGED_YAML_DIRS=$(echo -e "$CHANGED_YAML_DIRS" | sort -u | sed '/^$/d' | tr '\n' ' ')

          echo "Unique directories with changed .yaml files: ${CHANGED_YAML_DIRS}"

          # Iterate through the identified directories and check for deploy.sh
          declare -a DEPLOY_DIRS # Declare a bash array
          for DIR in $CHANGED_YAML_DIRS; do
              if [ -f "$DIR/deploy.sh" ]; then
                  DEPLOY_DIRS+=("$DIR")
                  echo "Found deployable service: $DIR (contains .yaml and deploy.sh)"
              else
                  echo "Skipping $DIR: .yaml changed but no deploy.sh found in the same directory."
              fi
          done

          # Format the array as a JSON string for GitHub Actions output
          if [ ${#DEPLOY_DIRS[@]} -eq 0 ]; then
            echo "No deployable service directories identified based on changes and deploy.sh presence."
            echo "STACK_DIRS_TO_DEPLOY=[]" >> $GITHUB_OUTPUT # Output empty array
          else
            # Convert bash array to JSON array string using jq
            JSON_ARRAY=$(printf '%s\n' "${DEPLOY_DIRS[@]}" | jq -R . | jq -cs .)
            echo "STACK_DIRS_TO_DEPLOY=$JSON_ARRAY" >> $GITHUB_OUTPUT
            echo "Service directories to deploy: $JSON_ARRAY"
          fi
        shell: bash

  # Job 2: Deploy each identified service in parallel
  deploy-each-service:
    runs-on: ubuntu-latest
    # This matrix strategy ensures each stack_dir from the previous job runs in parallel
    needs: [identify-deployable-services]
    strategy:
      fail-fast: false # Allows other parallel deployments to continue even if one fails
      matrix:
        stack_dir: ${{ fromJson(needs.identify-deployable-services.outputs.stack_dirs) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.9
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
      - name: Create unified-test AWS CLI Profile Files
        run: |
          mkdir -p ~/.aws
          
          # Create ~/.aws/config
          printf "[profile unified-test]\nregion = %s\noutput = json\n" "${{ env.AWS_REGION }}" > ~/.aws/config

          # Create ~/.aws/credentials
          if [ -n "${{ env.AWS_SESSION_TOKEN }}" ]; then
            echo "Detected AWS_SESSION_TOKEN, including in credentials."
            printf "[unified-test]\naws_access_key_id = %s\naws_secret_access_key = %s\naws_session_token = %s\n" \
                   "${{ secrets.AWS_ACCESS_KEY_ID }}" \
                   "${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                   "${{ env.AWS_SESSION_TOKEN }}" > ~/.aws/credentials
          else
            echo "No AWS_SESSION_TOKEN detected, creating credentials without it."
            printf "[unified-test]\naws_access_key_id = %s\naws_secret_access_key = %s\n" \
                   "${{ secrets.AWS_ACCESS_KEY_ID }}" \
                   "${{ secrets.AWS_SECRET_ACCESS_KEY }}" > ~/.aws/credentials
          fi
        shell: bash
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up bash for executable script
        # Ensure the specific deploy.sh for this matrix item is executable
        run: chmod +x ${{ matrix.stack_dir }}/deploy.sh
        shell: bash

      - name: Deploy Service to Test Environment
        working-directory: ${{ matrix.stack_dir }} # Navigate to the service's directory
        run: |
          echo "Deploying service in ${{ matrix.stack_dir }} to ${TEST_ENVIRONMENT_NAME} environment..."
          # Call your deploy.sh script with the test environment name
          ./deploy.sh -e ${{ env.TEST_ENVIRONMENT_NAME }}
        shell: bash
