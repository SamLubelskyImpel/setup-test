name: Deploy Changed Stacks to Test Environment

on:
  pull_request:
    types: [opened, reopened, synchronize] # Trigger on new PRs, reopened PRs, or new commits to an open PR

env:
  AWS_REGION: us-east-1 # Set your default AWS region for the test environment
  TEST_ENVIRONMENT_NAME: test # The exact environment name your deploy.sh expects for 'test'

jobs:
  # Job 1: Identify all changed service directories that can be deployed
  identify-deployable-services:
    runs-on: ubuntu-latest
    outputs:
      # Output a JSON array of directories to deploy, for the matrix strategy
      stack_dirs: ${{ steps.get_changed_service_dirs.outputs.STACK_DIRS_TO_DEPLOY }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 
      
      - name: Get changed services
        uses: ./.github/actions/find_changed_services/
        id: find-changed-services

      - name: Format Changed Services
        run: |
          RAW_CHANGED_SERVICES=${{ steps.find-changed-services.outputs.changed_services }}
          echo "RAW_CHANGED_SERVICES: $RAW_CHANGED_SERVICES"
          if [ -z "$RAW_CHANGED_SERVICES" ]; then
            echo "No changed services found"
            echo "changed_services=[]" >> $GITHUB_OUTPUT
          else
            JSON_ARRAY=$(echo "$RAW_CHANGED_SERVICES" | jq -R -s -c 'split(" ") | map(select(length > 0))')
            echo "JSON_ARRAY: $JSON_ARRAY"
            echo "changed_services=$JSON_ARRAY" >> $GITHUB_OUTPUT
          fi
        shell: bash

  # Job 2: Deploy each identified service in parallel
  deploy-each-service:
    runs-on: ubuntu-latest
    # This matrix strategy ensures each stack_dir from the previous job runs in parallel
    needs: [identify-deployable-services]
    strategy:
      fail-fast: false # Allows other parallel deployments to continue even if one fails
      matrix:
        stack_dir: ${{ fromJson(needs.identify-deployable-services.outputs.stack_dirs) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.9
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
      - name: Create unified-test AWS CLI Profile Files
        run: |
          mkdir -p ~/.aws
          
          # Create ~/.aws/config
          printf "[profile unified-test]\nregion = %s\noutput = json\n" "${{ env.AWS_REGION }}" > ~/.aws/config

          # Create ~/.aws/credentials
          if [ -n "${{ env.AWS_SESSION_TOKEN }}" ]; then
            echo "Detected AWS_SESSION_TOKEN, including in credentials."
            printf "[unified-test]\naws_access_key_id = %s\naws_secret_access_key = %s\naws_session_token = %s\n" \
                   "${{ secrets.AWS_ACCESS_KEY_ID }}" \
                   "${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                   "${{ env.AWS_SESSION_TOKEN }}" > ~/.aws/credentials
            printf "[unified-test]\nregion = %s\nsource_profile = default\noutput = json\nrole_arn=%s\n" \
                   "${{ secrets.AWS_REGION }}" \
                   "${{ secrets.ROLE_ARN }}" > ~/.aws/config
          else
            echo "No AWS_SESSION_TOKEN detected, creating credentials without it."
            printf "[default]\naws_access_key_id = %s\naws_secret_access_key = %s\n" \
                   "${{ secrets.AWS_ACCESS_KEY_ID }}" \
                   "${{ secrets.AWS_SECRET_ACCESS_KEY }}" > ~/.aws/credentials
            printf "[profile unified-test]\nregion = %s\nsource_profile = default\noutput = json\nrole_arn=%s\n" \
                   "${{ secrets.AWS_REGION }}" \
                   "${{ secrets.ROLE_ARN }}" > ~/.aws/config
          fi
        shell: bash
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up bash for executable script
        # Ensure the specific deploy.sh for this matrix item is executable
        run: chmod +x ${{ matrix.stack_dir }}/deploy.sh
        shell: bash

      - name: Deploy Service to Test Environment
        working-directory: ${{ matrix.stack_dir }} # Navigate to the service's directory
        run: |
          echo "Deploying service in ${{ matrix.stack_dir }} to ${TEST_ENVIRONMENT_NAME} environment..."
          # Call your deploy.sh script with the test environment name
          ./deploy.sh -e ${{ env.TEST_ENVIRONMENT_NAME }}
        shell: bash
