name: Deploy Changed Stacks to Test Environment

on:
  pull_request:
    types: [opened, reopened, synchronize] # Trigger on new PRs, reopened PRs, or new commits to an open PR

env:
  AWS_REGION: us-east-1 # Set your default AWS region for the test environment
  TEST_ENVIRONMENT_NAME: test # The exact environment name your deploy.sh expects for 'test'

jobs:
  # Job 1: Identify all changed service directories that can be deployed
  identify-deployable-services:
    runs-on: ubuntu-latest
    outputs:
      # Output a JSON array of directories to deploy, for the matrix strategy
      stack_dirs: ${{ steps.get_changed_service_dirs.outputs.STACK_DIRS_TO_DEPLOY }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get changed service directories with deploy.sh and .yaml
        id: get_changed_service_dirs
        run: |
          # Get all changed files in the PR
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          echo "All changed files: $CHANGED_FILES" # Debugging output

          # Find unique parent directories of changed .yaml files
          CHANGED_YAML_DIRS=$(echo "$CHANGED_FILES" | grep '\.yaml$' | xargs -I {} dirname {} | sort -u)
          echo "Directories with changed .yaml files: $CHANGED_YAML_DIRS"

          # Use a bash array to collect the directories
          declare -a DEPLOY_DIRS
          for DIR in $CHANGED_YAML_DIRS; do
              # Check if a deploy.sh exists in the same directory
              if [ -f "$DIR/deploy.sh" ]; then
                  DEPLOY_DIRS+=("$DIR")
                  echo "Found deployable service: $DIR"
              else
                  echo "Skipping $DIR: .yaml changed but no deploy.sh found."
              fi
          done

          # Format the array as a JSON string for GitHub Actions output
          if [ ${#DEPLOY_DIRS[@]} -eq 0 ]; then
            echo "No deployable service directories identified based on changes."
            echo "STACK_DIRS_TO_DEPLOY=[]" >> $GITHUB_OUTPUT # Output empty array
          else
            # Convert bash array to JSON array string
            JSON_ARRAY=$(printf '%s\n' "${DEPLOY_DIRS[@]}" | jq -R . | jq -cs .)
            echo "STACK_DIRS_TO_DEPLOY=$JSON_ARRAY" >> $GITHUB_OUTPUT
            echo "Service directories to deploy: $JSON_ARRAY"
          fi
        shell: bash

  # Job 2: Deploy each identified service in parallel
  deploy-each-service:
    runs-on: ubuntu-latest
    # This matrix strategy ensures each stack_dir from the previous job runs in parallel
    needs: [identify-deployable-services]
    strategy:
      fail-fast: false # Allows other parallel deployments to continue even if one fails
      matrix:
        stack_dir: ${{ fromJson(needs.identify-deployable-services.outputs.stack_dirs) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up bash for executable script
        # Ensure the specific deploy.sh for this matrix item is executable
        run: chmod +x ${{ matrix.stack_dir }}/deploy.sh
        shell: bash

      - name: Deploy Service to Test Environment
        working-directory: ${{ matrix.stack_dir }} # Navigate to the service's directory
        run: |
          echo "Deploying service in ${{ matrix.stack_dir }} to ${TEST_ENVIRONMENT_NAME} environment..."
          # Call your deploy.sh script with the test environment name
          ./deploy.sh -e ${{ env.TEST_ENVIRONMENT_NAME }}
        shell: bash
